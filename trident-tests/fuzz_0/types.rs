//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: svs_1
// ----------------------------------------------------------------------------
pub mod svs_1 {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for svs_1
    pub fn program_id() -> Pubkey {
        pubkey!("SVS1VauLt1111111111111111111111111111111111")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: ConvertToAssets
    // ....................................................................

    /// Main instruction struct for ConvertToAssets
    pub struct ConvertToAssetsInstruction {
        pub accounts: ConvertToAssetsInstructionAccountMetas,
        pub data: ConvertToAssetsInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ConvertToAssets instruction
    #[derive(Debug, Clone, Default)]
    pub struct ConvertToAssetsInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for ConvertToAssets instruction
    #[derive(Debug, Clone)]
    pub struct ConvertToAssetsInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl ConvertToAssetsInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for ConvertToAssets
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ConvertToAssetsInstructionData {
        pub shares: u64,
    }

    impl ConvertToAssetsInstructionData {
        pub fn new(shares: u64) -> Self {
            Self { shares }
        }
    }

    /// Implementation for ConvertToAssetsInstruction
    impl ConvertToAssetsInstruction {
        fn discriminator() -> [u8; 8] {
            [229u8, 109u8, 118u8, 143u8, 110u8, 190u8, 39u8, 123u8]
        }

        pub fn data(data: ConvertToAssetsInstructionData) -> Self {
            Self {
                accounts: ConvertToAssetsInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ConvertToAssetsInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ConvertToShares
    // ....................................................................

    /// Main instruction struct for ConvertToShares
    pub struct ConvertToSharesInstruction {
        pub accounts: ConvertToSharesInstructionAccountMetas,
        pub data: ConvertToSharesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ConvertToShares instruction
    #[derive(Debug, Clone, Default)]
    pub struct ConvertToSharesInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for ConvertToShares instruction
    #[derive(Debug, Clone)]
    pub struct ConvertToSharesInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl ConvertToSharesInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for ConvertToShares
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ConvertToSharesInstructionData {
        pub assets: u64,
    }

    impl ConvertToSharesInstructionData {
        pub fn new(assets: u64) -> Self {
            Self { assets }
        }
    }

    /// Implementation for ConvertToSharesInstruction
    impl ConvertToSharesInstruction {
        fn discriminator() -> [u8; 8] {
            [105u8, 52u8, 27u8, 205u8, 69u8, 47u8, 239u8, 221u8]
        }

        pub fn data(data: ConvertToSharesInstructionData) -> Self {
            Self {
                accounts: ConvertToSharesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ConvertToSharesInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Deposit
    // ....................................................................

    /// Main instruction struct for Deposit
    pub struct DepositInstruction {
        pub accounts: DepositInstructionAccountMetas,
        pub data: DepositInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Deposit instruction
    #[derive(Debug, Clone, Default)]
    pub struct DepositInstructionAccountMetas {
        pub user: AccountMeta,

        pub vault: AccountMeta,

        pub asset_mint: AccountMeta,

        pub user_asset_account: AccountMeta,

        pub asset_vault: AccountMeta,

        pub shares_mint: AccountMeta,

        pub user_shares_account: AccountMeta,

        pub asset_token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for Deposit instruction
    #[derive(Debug, Clone)]
    pub struct DepositInstructionAccounts {
        pub user: Pubkey,

        pub vault: Pubkey,

        pub asset_mint: Pubkey,

        pub user_asset_account: Pubkey,

        pub asset_vault: Pubkey,

        pub shares_mint: Pubkey,

        pub user_shares_account: Pubkey,

        pub asset_token_program: Pubkey,
    }

    impl DepositInstructionAccounts {
        pub fn new(
            user: Pubkey,

            vault: Pubkey,

            asset_mint: Pubkey,

            user_asset_account: Pubkey,

            asset_vault: Pubkey,

            shares_mint: Pubkey,

            user_shares_account: Pubkey,

            asset_token_program: Pubkey,
        ) -> Self {
            Self {
                user,

                vault,

                asset_mint,

                user_asset_account,

                asset_vault,

                shares_mint,

                user_shares_account,

                asset_token_program,
            }
        }
    }

    /// Instruction data for Deposit
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct DepositInstructionData {
        pub assets: u64,

        pub min_shares_out: u64,
    }

    impl DepositInstructionData {
        pub fn new(assets: u64, min_shares_out: u64) -> Self {
            Self {
                assets,

                min_shares_out,
            }
        }
    }

    /// Implementation for DepositInstruction
    impl DepositInstruction {
        fn discriminator() -> [u8; 8] {
            [242u8, 35u8, 198u8, 137u8, 82u8, 225u8, 242u8, 182u8]
        }

        pub fn data(data: DepositInstructionData) -> Self {
            Self {
                accounts: DepositInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: DepositInstructionAccounts) -> Self {
            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self.accounts.asset_mint = AccountMeta::new_readonly(accounts.asset_mint, false);

            self.accounts.user_asset_account = AccountMeta::new(accounts.user_asset_account, false);

            self.accounts.asset_vault = AccountMeta::new(accounts.asset_vault, false);

            self.accounts.shares_mint = AccountMeta::new(accounts.shares_mint, false);

            self.accounts.user_shares_account =
                AccountMeta::new(accounts.user_shares_account, false);

            self.accounts.asset_token_program =
                AccountMeta::new_readonly(accounts.asset_token_program, false);

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.asset_mint.clone());

            metas.push(self.accounts.user_asset_account.clone());

            metas.push(self.accounts.asset_vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.user_shares_account.clone());

            metas.push(self.accounts.asset_token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Initialize
    // ....................................................................

    /// Main instruction struct for Initialize
    pub struct InitializeInstruction {
        pub accounts: InitializeInstructionAccountMetas,
        pub data: InitializeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Initialize instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeInstructionAccountMetas {
        pub authority: AccountMeta,

        pub vault: AccountMeta,

        pub asset_mint: AccountMeta,

        pub shares_mint: AccountMeta,

        pub asset_vault: AccountMeta,

        pub asset_token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,

        pub rent: AccountMeta,
    }

    /// Account pubkeys for Initialize instruction
    #[derive(Debug, Clone)]
    pub struct InitializeInstructionAccounts {
        pub authority: Pubkey,

        pub vault: Pubkey,

        pub asset_mint: Pubkey,

        pub shares_mint: Pubkey,

        pub asset_vault: Pubkey,

        pub asset_token_program: Pubkey,
    }

    impl InitializeInstructionAccounts {
        pub fn new(
            authority: Pubkey,

            vault: Pubkey,

            asset_mint: Pubkey,

            shares_mint: Pubkey,

            asset_vault: Pubkey,

            asset_token_program: Pubkey,
        ) -> Self {
            Self {
                authority,

                vault,

                asset_mint,

                shares_mint,

                asset_vault,

                asset_token_program,
            }
        }
    }

    /// Instruction data for Initialize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeInstructionData {
        pub vault_id: u64,

        pub name: String,

        pub symbol: String,

        pub uri: String,
    }

    impl InitializeInstructionData {
        pub fn new(vault_id: u64, name: String, symbol: String, uri: String) -> Self {
            Self {
                vault_id,

                name,

                symbol,

                uri,
            }
        }
    }

    /// Implementation for InitializeInstruction
    impl InitializeInstruction {
        fn discriminator() -> [u8; 8] {
            [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8]
        }

        pub fn data(data: InitializeInstructionData) -> Self {
            Self {
                accounts: InitializeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self.accounts.asset_mint = AccountMeta::new_readonly(accounts.asset_mint, false);

            self.accounts.shares_mint = AccountMeta::new(accounts.shares_mint, false);

            self.accounts.asset_vault = AccountMeta::new(accounts.asset_vault, false);

            self.accounts.asset_token_program =
                AccountMeta::new_readonly(accounts.asset_token_program, false);

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.rent = AccountMeta::new_readonly(
                pubkey!("SysvarRent111111111111111111111111111111111"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.asset_mint.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.asset_vault.clone());

            metas.push(self.accounts.asset_token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.rent.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MaxDeposit
    // ....................................................................

    /// Main instruction struct for MaxDeposit
    pub struct MaxDepositInstruction {
        pub accounts: MaxDepositInstructionAccountMetas,
        pub data: MaxDepositInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MaxDeposit instruction
    #[derive(Debug, Clone, Default)]
    pub struct MaxDepositInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for MaxDeposit instruction
    #[derive(Debug, Clone)]
    pub struct MaxDepositInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl MaxDepositInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for MaxDeposit
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MaxDepositInstructionData {}

    impl MaxDepositInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for MaxDepositInstruction
    impl MaxDepositInstruction {
        fn discriminator() -> [u8; 8] {
            [160u8, 113u8, 66u8, 36u8, 132u8, 127u8, 192u8, 252u8]
        }

        pub fn data(data: MaxDepositInstructionData) -> Self {
            Self {
                accounts: MaxDepositInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MaxDepositInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MaxMint
    // ....................................................................

    /// Main instruction struct for MaxMint
    pub struct MaxMintInstruction {
        pub accounts: MaxMintInstructionAccountMetas,
        pub data: MaxMintInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MaxMint instruction
    #[derive(Debug, Clone, Default)]
    pub struct MaxMintInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for MaxMint instruction
    #[derive(Debug, Clone)]
    pub struct MaxMintInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl MaxMintInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for MaxMint
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MaxMintInstructionData {}

    impl MaxMintInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for MaxMintInstruction
    impl MaxMintInstruction {
        fn discriminator() -> [u8; 8] {
            [110u8, 223u8, 78u8, 157u8, 235u8, 80u8, 65u8, 229u8]
        }

        pub fn data(data: MaxMintInstructionData) -> Self {
            Self {
                accounts: MaxMintInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MaxMintInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MaxRedeem
    // ....................................................................

    /// Main instruction struct for MaxRedeem
    pub struct MaxRedeemInstruction {
        pub accounts: MaxRedeemInstructionAccountMetas,
        pub data: MaxRedeemInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MaxRedeem instruction
    #[derive(Debug, Clone, Default)]
    pub struct MaxRedeemInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,

        pub owner_shares_account: AccountMeta,
    }

    /// Account pubkeys for MaxRedeem instruction
    #[derive(Debug, Clone)]
    pub struct MaxRedeemInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,

        pub owner_shares_account: Pubkey,
    }

    impl MaxRedeemInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey, owner_shares_account: Pubkey) -> Self {
            Self {
                vault,

                shares_mint,

                owner_shares_account,
            }
        }
    }

    /// Instruction data for MaxRedeem
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MaxRedeemInstructionData {}

    impl MaxRedeemInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for MaxRedeemInstruction
    impl MaxRedeemInstruction {
        fn discriminator() -> [u8; 8] {
            [65u8, 154u8, 51u8, 37u8, 235u8, 156u8, 235u8, 72u8]
        }

        pub fn data(data: MaxRedeemInstructionData) -> Self {
            Self {
                accounts: MaxRedeemInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MaxRedeemInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self.accounts.owner_shares_account =
                AccountMeta::new_readonly(accounts.owner_shares_account, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.owner_shares_account.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MaxWithdraw
    // ....................................................................

    /// Main instruction struct for MaxWithdraw
    pub struct MaxWithdrawInstruction {
        pub accounts: MaxWithdrawInstructionAccountMetas,
        pub data: MaxWithdrawInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MaxWithdraw instruction
    #[derive(Debug, Clone, Default)]
    pub struct MaxWithdrawInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,

        pub owner_shares_account: AccountMeta,
    }

    /// Account pubkeys for MaxWithdraw instruction
    #[derive(Debug, Clone)]
    pub struct MaxWithdrawInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,

        pub owner_shares_account: Pubkey,
    }

    impl MaxWithdrawInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey, owner_shares_account: Pubkey) -> Self {
            Self {
                vault,

                shares_mint,

                owner_shares_account,
            }
        }
    }

    /// Instruction data for MaxWithdraw
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MaxWithdrawInstructionData {}

    impl MaxWithdrawInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for MaxWithdrawInstruction
    impl MaxWithdrawInstruction {
        fn discriminator() -> [u8; 8] {
            [120u8, 205u8, 134u8, 47u8, 124u8, 123u8, 74u8, 119u8]
        }

        pub fn data(data: MaxWithdrawInstructionData) -> Self {
            Self {
                accounts: MaxWithdrawInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MaxWithdrawInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self.accounts.owner_shares_account =
                AccountMeta::new_readonly(accounts.owner_shares_account, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.owner_shares_account.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Mint
    // ....................................................................

    /// Main instruction struct for Mint
    pub struct MintInstruction {
        pub accounts: MintInstructionAccountMetas,
        pub data: MintInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Mint instruction
    #[derive(Debug, Clone, Default)]
    pub struct MintInstructionAccountMetas {
        pub user: AccountMeta,

        pub vault: AccountMeta,

        pub asset_mint: AccountMeta,

        pub user_asset_account: AccountMeta,

        pub asset_vault: AccountMeta,

        pub shares_mint: AccountMeta,

        pub user_shares_account: AccountMeta,

        pub asset_token_program: AccountMeta,

        pub token_2022_program: AccountMeta,

        pub associated_token_program: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for Mint instruction
    #[derive(Debug, Clone)]
    pub struct MintInstructionAccounts {
        pub user: Pubkey,

        pub vault: Pubkey,

        pub asset_mint: Pubkey,

        pub user_asset_account: Pubkey,

        pub asset_vault: Pubkey,

        pub shares_mint: Pubkey,

        pub user_shares_account: Pubkey,

        pub asset_token_program: Pubkey,
    }

    impl MintInstructionAccounts {
        pub fn new(
            user: Pubkey,

            vault: Pubkey,

            asset_mint: Pubkey,

            user_asset_account: Pubkey,

            asset_vault: Pubkey,

            shares_mint: Pubkey,

            user_shares_account: Pubkey,

            asset_token_program: Pubkey,
        ) -> Self {
            Self {
                user,

                vault,

                asset_mint,

                user_asset_account,

                asset_vault,

                shares_mint,

                user_shares_account,

                asset_token_program,
            }
        }
    }

    /// Instruction data for Mint
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MintInstructionData {
        pub shares: u64,

        pub max_assets_in: u64,
    }

    impl MintInstructionData {
        pub fn new(shares: u64, max_assets_in: u64) -> Self {
            Self {
                shares,

                max_assets_in,
            }
        }
    }

    /// Implementation for MintInstruction
    impl MintInstruction {
        fn discriminator() -> [u8; 8] {
            [51u8, 57u8, 225u8, 47u8, 182u8, 146u8, 137u8, 166u8]
        }

        pub fn data(data: MintInstructionData) -> Self {
            Self {
                accounts: MintInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MintInstructionAccounts) -> Self {
            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self.accounts.asset_mint = AccountMeta::new_readonly(accounts.asset_mint, false);

            self.accounts.user_asset_account = AccountMeta::new(accounts.user_asset_account, false);

            self.accounts.asset_vault = AccountMeta::new(accounts.asset_vault, false);

            self.accounts.shares_mint = AccountMeta::new(accounts.shares_mint, false);

            self.accounts.user_shares_account =
                AccountMeta::new(accounts.user_shares_account, false);

            self.accounts.asset_token_program =
                AccountMeta::new_readonly(accounts.asset_token_program, false);

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.associated_token_program = AccountMeta::new_readonly(
                pubkey!("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.asset_mint.clone());

            metas.push(self.accounts.user_asset_account.clone());

            metas.push(self.accounts.asset_vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.user_shares_account.clone());

            metas.push(self.accounts.asset_token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.push(self.accounts.associated_token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Pause
    // ....................................................................

    /// Main instruction struct for Pause
    pub struct PauseInstruction {
        pub accounts: PauseInstructionAccountMetas,
        pub data: PauseInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Pause instruction
    #[derive(Debug, Clone, Default)]
    pub struct PauseInstructionAccountMetas {
        pub authority: AccountMeta,

        pub vault: AccountMeta,
    }

    /// Account pubkeys for Pause instruction
    #[derive(Debug, Clone)]
    pub struct PauseInstructionAccounts {
        pub authority: Pubkey,

        pub vault: Pubkey,
    }

    impl PauseInstructionAccounts {
        pub fn new(authority: Pubkey, vault: Pubkey) -> Self {
            Self { authority, vault }
        }
    }

    /// Instruction data for Pause
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PauseInstructionData {}

    impl PauseInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for PauseInstruction
    impl PauseInstruction {
        fn discriminator() -> [u8; 8] {
            [211u8, 22u8, 221u8, 251u8, 74u8, 121u8, 193u8, 47u8]
        }

        pub fn data(data: PauseInstructionData) -> Self {
            Self {
                accounts: PauseInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PauseInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.vault.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: PreviewDeposit
    // ....................................................................

    /// Main instruction struct for PreviewDeposit
    pub struct PreviewDepositInstruction {
        pub accounts: PreviewDepositInstructionAccountMetas,
        pub data: PreviewDepositInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for PreviewDeposit instruction
    #[derive(Debug, Clone, Default)]
    pub struct PreviewDepositInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for PreviewDeposit instruction
    #[derive(Debug, Clone)]
    pub struct PreviewDepositInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl PreviewDepositInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for PreviewDeposit
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PreviewDepositInstructionData {
        pub assets: u64,
    }

    impl PreviewDepositInstructionData {
        pub fn new(assets: u64) -> Self {
            Self { assets }
        }
    }

    /// Implementation for PreviewDepositInstruction
    impl PreviewDepositInstruction {
        fn discriminator() -> [u8; 8] {
            [16u8, 61u8, 8u8, 235u8, 146u8, 126u8, 80u8, 84u8]
        }

        pub fn data(data: PreviewDepositInstructionData) -> Self {
            Self {
                accounts: PreviewDepositInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PreviewDepositInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: PreviewMint
    // ....................................................................

    /// Main instruction struct for PreviewMint
    pub struct PreviewMintInstruction {
        pub accounts: PreviewMintInstructionAccountMetas,
        pub data: PreviewMintInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for PreviewMint instruction
    #[derive(Debug, Clone, Default)]
    pub struct PreviewMintInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for PreviewMint instruction
    #[derive(Debug, Clone)]
    pub struct PreviewMintInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl PreviewMintInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for PreviewMint
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PreviewMintInstructionData {
        pub shares: u64,
    }

    impl PreviewMintInstructionData {
        pub fn new(shares: u64) -> Self {
            Self { shares }
        }
    }

    /// Implementation for PreviewMintInstruction
    impl PreviewMintInstruction {
        fn discriminator() -> [u8; 8] {
            [42u8, 71u8, 86u8, 125u8, 215u8, 190u8, 214u8, 81u8]
        }

        pub fn data(data: PreviewMintInstructionData) -> Self {
            Self {
                accounts: PreviewMintInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PreviewMintInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: PreviewRedeem
    // ....................................................................

    /// Main instruction struct for PreviewRedeem
    pub struct PreviewRedeemInstruction {
        pub accounts: PreviewRedeemInstructionAccountMetas,
        pub data: PreviewRedeemInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for PreviewRedeem instruction
    #[derive(Debug, Clone, Default)]
    pub struct PreviewRedeemInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for PreviewRedeem instruction
    #[derive(Debug, Clone)]
    pub struct PreviewRedeemInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl PreviewRedeemInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for PreviewRedeem
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PreviewRedeemInstructionData {
        pub shares: u64,
    }

    impl PreviewRedeemInstructionData {
        pub fn new(shares: u64) -> Self {
            Self { shares }
        }
    }

    /// Implementation for PreviewRedeemInstruction
    impl PreviewRedeemInstruction {
        fn discriminator() -> [u8; 8] {
            [122u8, 195u8, 125u8, 8u8, 168u8, 149u8, 50u8, 40u8]
        }

        pub fn data(data: PreviewRedeemInstructionData) -> Self {
            Self {
                accounts: PreviewRedeemInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PreviewRedeemInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: PreviewWithdraw
    // ....................................................................

    /// Main instruction struct for PreviewWithdraw
    pub struct PreviewWithdrawInstruction {
        pub accounts: PreviewWithdrawInstructionAccountMetas,
        pub data: PreviewWithdrawInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for PreviewWithdraw instruction
    #[derive(Debug, Clone, Default)]
    pub struct PreviewWithdrawInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for PreviewWithdraw instruction
    #[derive(Debug, Clone)]
    pub struct PreviewWithdrawInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl PreviewWithdrawInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for PreviewWithdraw
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PreviewWithdrawInstructionData {
        pub assets: u64,
    }

    impl PreviewWithdrawInstructionData {
        pub fn new(assets: u64) -> Self {
            Self { assets }
        }
    }

    /// Implementation for PreviewWithdrawInstruction
    impl PreviewWithdrawInstruction {
        fn discriminator() -> [u8; 8] {
            [66u8, 3u8, 217u8, 38u8, 187u8, 176u8, 144u8, 135u8]
        }

        pub fn data(data: PreviewWithdrawInstructionData) -> Self {
            Self {
                accounts: PreviewWithdrawInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PreviewWithdrawInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Redeem
    // ....................................................................

    /// Main instruction struct for Redeem
    pub struct RedeemInstruction {
        pub accounts: RedeemInstructionAccountMetas,
        pub data: RedeemInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Redeem instruction
    #[derive(Debug, Clone, Default)]
    pub struct RedeemInstructionAccountMetas {
        pub user: AccountMeta,

        pub vault: AccountMeta,

        pub asset_mint: AccountMeta,

        pub user_asset_account: AccountMeta,

        pub asset_vault: AccountMeta,

        pub shares_mint: AccountMeta,

        pub user_shares_account: AccountMeta,

        pub asset_token_program: AccountMeta,

        pub token_2022_program: AccountMeta,
    }

    /// Account pubkeys for Redeem instruction
    #[derive(Debug, Clone)]
    pub struct RedeemInstructionAccounts {
        pub user: Pubkey,

        pub vault: Pubkey,

        pub asset_mint: Pubkey,

        pub user_asset_account: Pubkey,

        pub asset_vault: Pubkey,

        pub shares_mint: Pubkey,

        pub user_shares_account: Pubkey,

        pub asset_token_program: Pubkey,
    }

    impl RedeemInstructionAccounts {
        pub fn new(
            user: Pubkey,

            vault: Pubkey,

            asset_mint: Pubkey,

            user_asset_account: Pubkey,

            asset_vault: Pubkey,

            shares_mint: Pubkey,

            user_shares_account: Pubkey,

            asset_token_program: Pubkey,
        ) -> Self {
            Self {
                user,

                vault,

                asset_mint,

                user_asset_account,

                asset_vault,

                shares_mint,

                user_shares_account,

                asset_token_program,
            }
        }
    }

    /// Instruction data for Redeem
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RedeemInstructionData {
        pub shares: u64,

        pub min_assets_out: u64,
    }

    impl RedeemInstructionData {
        pub fn new(shares: u64, min_assets_out: u64) -> Self {
            Self {
                shares,

                min_assets_out,
            }
        }
    }

    /// Implementation for RedeemInstruction
    impl RedeemInstruction {
        fn discriminator() -> [u8; 8] {
            [184u8, 12u8, 86u8, 149u8, 70u8, 196u8, 97u8, 225u8]
        }

        pub fn data(data: RedeemInstructionData) -> Self {
            Self {
                accounts: RedeemInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RedeemInstructionAccounts) -> Self {
            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self.accounts.asset_mint = AccountMeta::new_readonly(accounts.asset_mint, false);

            self.accounts.user_asset_account = AccountMeta::new(accounts.user_asset_account, false);

            self.accounts.asset_vault = AccountMeta::new(accounts.asset_vault, false);

            self.accounts.shares_mint = AccountMeta::new(accounts.shares_mint, false);

            self.accounts.user_shares_account =
                AccountMeta::new(accounts.user_shares_account, false);

            self.accounts.asset_token_program =
                AccountMeta::new_readonly(accounts.asset_token_program, false);

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.asset_mint.clone());

            metas.push(self.accounts.user_asset_account.clone());

            metas.push(self.accounts.asset_vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.user_shares_account.clone());

            metas.push(self.accounts.asset_token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Sync
    // ....................................................................

    /// Main instruction struct for Sync
    pub struct SyncInstruction {
        pub accounts: SyncInstructionAccountMetas,
        pub data: SyncInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Sync instruction
    #[derive(Debug, Clone, Default)]
    pub struct SyncInstructionAccountMetas {
        pub authority: AccountMeta,

        pub vault: AccountMeta,

        pub asset_vault: AccountMeta,
    }

    /// Account pubkeys for Sync instruction
    #[derive(Debug, Clone)]
    pub struct SyncInstructionAccounts {
        pub authority: Pubkey,

        pub vault: Pubkey,

        pub asset_vault: Pubkey,
    }

    impl SyncInstructionAccounts {
        pub fn new(authority: Pubkey, vault: Pubkey, asset_vault: Pubkey) -> Self {
            Self {
                authority,

                vault,

                asset_vault,
            }
        }
    }

    /// Instruction data for Sync
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct SyncInstructionData {}

    impl SyncInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for SyncInstruction
    impl SyncInstruction {
        fn discriminator() -> [u8; 8] {
            [4u8, 219u8, 40u8, 164u8, 21u8, 157u8, 189u8, 88u8]
        }

        pub fn data(data: SyncInstructionData) -> Self {
            Self {
                accounts: SyncInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: SyncInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self.accounts.asset_vault = AccountMeta::new_readonly(accounts.asset_vault, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.asset_vault.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: TotalAssets
    // ....................................................................

    /// Main instruction struct for TotalAssets
    pub struct TotalAssetsInstruction {
        pub accounts: TotalAssetsInstructionAccountMetas,
        pub data: TotalAssetsInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for TotalAssets instruction
    #[derive(Debug, Clone, Default)]
    pub struct TotalAssetsInstructionAccountMetas {
        pub vault: AccountMeta,

        pub shares_mint: AccountMeta,
    }

    /// Account pubkeys for TotalAssets instruction
    #[derive(Debug, Clone)]
    pub struct TotalAssetsInstructionAccounts {
        pub vault: Pubkey,

        pub shares_mint: Pubkey,
    }

    impl TotalAssetsInstructionAccounts {
        pub fn new(vault: Pubkey, shares_mint: Pubkey) -> Self {
            Self { vault, shares_mint }
        }
    }

    /// Instruction data for TotalAssets
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct TotalAssetsInstructionData {}

    impl TotalAssetsInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for TotalAssetsInstruction
    impl TotalAssetsInstruction {
        fn discriminator() -> [u8; 8] {
            [21u8, 211u8, 56u8, 201u8, 244u8, 191u8, 106u8, 230u8]
        }

        pub fn data(data: TotalAssetsInstructionData) -> Self {
            Self {
                accounts: TotalAssetsInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: TotalAssetsInstructionAccounts) -> Self {
            self.accounts.vault = AccountMeta::new_readonly(accounts.vault, false);

            self.accounts.shares_mint = AccountMeta::new_readonly(accounts.shares_mint, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: TransferAuthority
    // ....................................................................

    /// Main instruction struct for TransferAuthority
    pub struct TransferAuthorityInstruction {
        pub accounts: TransferAuthorityInstructionAccountMetas,
        pub data: TransferAuthorityInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for TransferAuthority instruction
    #[derive(Debug, Clone, Default)]
    pub struct TransferAuthorityInstructionAccountMetas {
        pub authority: AccountMeta,

        pub vault: AccountMeta,
    }

    /// Account pubkeys for TransferAuthority instruction
    #[derive(Debug, Clone)]
    pub struct TransferAuthorityInstructionAccounts {
        pub authority: Pubkey,

        pub vault: Pubkey,
    }

    impl TransferAuthorityInstructionAccounts {
        pub fn new(authority: Pubkey, vault: Pubkey) -> Self {
            Self { authority, vault }
        }
    }

    /// Instruction data for TransferAuthority
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct TransferAuthorityInstructionData {
        pub new_authority: Pubkey,
    }

    impl TransferAuthorityInstructionData {
        pub fn new(new_authority: Pubkey) -> Self {
            Self { new_authority }
        }
    }

    /// Implementation for TransferAuthorityInstruction
    impl TransferAuthorityInstruction {
        fn discriminator() -> [u8; 8] {
            [48u8, 169u8, 76u8, 72u8, 229u8, 180u8, 55u8, 161u8]
        }

        pub fn data(data: TransferAuthorityInstructionData) -> Self {
            Self {
                accounts: TransferAuthorityInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: TransferAuthorityInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.vault.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Unpause
    // ....................................................................

    /// Main instruction struct for Unpause
    pub struct UnpauseInstruction {
        pub accounts: UnpauseInstructionAccountMetas,
        pub data: UnpauseInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Unpause instruction
    #[derive(Debug, Clone, Default)]
    pub struct UnpauseInstructionAccountMetas {
        pub authority: AccountMeta,

        pub vault: AccountMeta,
    }

    /// Account pubkeys for Unpause instruction
    #[derive(Debug, Clone)]
    pub struct UnpauseInstructionAccounts {
        pub authority: Pubkey,

        pub vault: Pubkey,
    }

    impl UnpauseInstructionAccounts {
        pub fn new(authority: Pubkey, vault: Pubkey) -> Self {
            Self { authority, vault }
        }
    }

    /// Instruction data for Unpause
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct UnpauseInstructionData {}

    impl UnpauseInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for UnpauseInstruction
    impl UnpauseInstruction {
        fn discriminator() -> [u8; 8] {
            [169u8, 144u8, 4u8, 38u8, 10u8, 141u8, 188u8, 255u8]
        }

        pub fn data(data: UnpauseInstructionData) -> Self {
            Self {
                accounts: UnpauseInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: UnpauseInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.vault.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Withdraw
    // ....................................................................

    /// Main instruction struct for Withdraw
    pub struct WithdrawInstruction {
        pub accounts: WithdrawInstructionAccountMetas,
        pub data: WithdrawInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Withdraw instruction
    #[derive(Debug, Clone, Default)]
    pub struct WithdrawInstructionAccountMetas {
        pub user: AccountMeta,

        pub vault: AccountMeta,

        pub asset_mint: AccountMeta,

        pub user_asset_account: AccountMeta,

        pub asset_vault: AccountMeta,

        pub shares_mint: AccountMeta,

        pub user_shares_account: AccountMeta,

        pub asset_token_program: AccountMeta,

        pub token_2022_program: AccountMeta,
    }

    /// Account pubkeys for Withdraw instruction
    #[derive(Debug, Clone)]
    pub struct WithdrawInstructionAccounts {
        pub user: Pubkey,

        pub vault: Pubkey,

        pub asset_mint: Pubkey,

        pub user_asset_account: Pubkey,

        pub asset_vault: Pubkey,

        pub shares_mint: Pubkey,

        pub user_shares_account: Pubkey,

        pub asset_token_program: Pubkey,
    }

    impl WithdrawInstructionAccounts {
        pub fn new(
            user: Pubkey,

            vault: Pubkey,

            asset_mint: Pubkey,

            user_asset_account: Pubkey,

            asset_vault: Pubkey,

            shares_mint: Pubkey,

            user_shares_account: Pubkey,

            asset_token_program: Pubkey,
        ) -> Self {
            Self {
                user,

                vault,

                asset_mint,

                user_asset_account,

                asset_vault,

                shares_mint,

                user_shares_account,

                asset_token_program,
            }
        }
    }

    /// Instruction data for Withdraw
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct WithdrawInstructionData {
        pub assets: u64,

        pub max_shares_in: u64,
    }

    impl WithdrawInstructionData {
        pub fn new(assets: u64, max_shares_in: u64) -> Self {
            Self {
                assets,

                max_shares_in,
            }
        }
    }

    /// Implementation for WithdrawInstruction
    impl WithdrawInstruction {
        fn discriminator() -> [u8; 8] {
            [183u8, 18u8, 70u8, 156u8, 148u8, 109u8, 161u8, 34u8]
        }

        pub fn data(data: WithdrawInstructionData) -> Self {
            Self {
                accounts: WithdrawInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: WithdrawInstructionAccounts) -> Self {
            self.accounts.user = AccountMeta::new(accounts.user, true);

            self.accounts.vault = AccountMeta::new(accounts.vault, false);

            self.accounts.asset_mint = AccountMeta::new_readonly(accounts.asset_mint, false);

            self.accounts.user_asset_account = AccountMeta::new(accounts.user_asset_account, false);

            self.accounts.asset_vault = AccountMeta::new(accounts.asset_vault, false);

            self.accounts.shares_mint = AccountMeta::new(accounts.shares_mint, false);

            self.accounts.user_shares_account =
                AccountMeta::new(accounts.user_shares_account, false);

            self.accounts.asset_token_program =
                AccountMeta::new_readonly(accounts.asset_token_program, false);

            self.accounts.token_2022_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.user.clone());

            metas.push(self.accounts.vault.clone());

            metas.push(self.accounts.asset_mint.clone());

            metas.push(self.accounts.user_asset_account.clone());

            metas.push(self.accounts.asset_vault.clone());

            metas.push(self.accounts.shares_mint.clone());

            metas.push(self.accounts.user_shares_account.clone());

            metas.push(self.accounts.asset_token_program.clone());

            metas.push(self.accounts.token_2022_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: AuthorityTransferred
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AuthorityTransferred {
    pub vault: Pubkey,

    pub previous_authority: Pubkey,

    pub new_authority: Pubkey,
}

impl AuthorityTransferred {
    pub fn new(vault: Pubkey, previous_authority: Pubkey, new_authority: Pubkey) -> Self {
        Self {
            vault,

            previous_authority,

            new_authority,
        }
    }
}

/// Custom struct: Deposit
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Deposit {
    pub vault: Pubkey,

    pub caller: Pubkey,

    pub owner: Pubkey,

    pub assets: u64,

    pub shares: u64,
}

impl Deposit {
    pub fn new(vault: Pubkey, caller: Pubkey, owner: Pubkey, assets: u64, shares: u64) -> Self {
        Self {
            vault,

            caller,

            owner,

            assets,

            shares,
        }
    }
}

/// Custom struct: Vault
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Vault {
    pub authority: Pubkey,

    pub asset_mint: Pubkey,

    pub shares_mint: Pubkey,

    pub asset_vault: Pubkey,

    pub total_assets: u64,

    pub decimals_offset: u8,

    pub bump: u8,

    pub paused: bool,

    pub vault_id: u64,

    pub _reserved: [u8; 64],
}

impl Vault {
    pub fn new(
        authority: Pubkey,

        asset_mint: Pubkey,

        shares_mint: Pubkey,

        asset_vault: Pubkey,

        total_assets: u64,

        decimals_offset: u8,

        bump: u8,

        paused: bool,

        vault_id: u64,

        _reserved: [u8; 64],
    ) -> Self {
        Self {
            authority,

            asset_mint,

            shares_mint,

            asset_vault,

            total_assets,

            decimals_offset,

            bump,

            paused,

            vault_id,

            _reserved,
        }
    }
}

/// Custom struct: VaultInitialized
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct VaultInitialized {
    pub vault: Pubkey,

    pub authority: Pubkey,

    pub asset_mint: Pubkey,

    pub shares_mint: Pubkey,

    pub vault_id: u64,
}

impl VaultInitialized {
    pub fn new(
        vault: Pubkey,

        authority: Pubkey,

        asset_mint: Pubkey,

        shares_mint: Pubkey,

        vault_id: u64,
    ) -> Self {
        Self {
            vault,

            authority,

            asset_mint,

            shares_mint,

            vault_id,
        }
    }
}

/// Custom struct: VaultStatusChanged
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct VaultStatusChanged {
    pub vault: Pubkey,

    pub paused: bool,
}

impl VaultStatusChanged {
    pub fn new(vault: Pubkey, paused: bool) -> Self {
        Self { vault, paused }
    }
}

/// Custom struct: VaultSynced
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct VaultSynced {
    pub vault: Pubkey,

    pub previous_total: u64,

    pub new_total: u64,
}

impl VaultSynced {
    pub fn new(vault: Pubkey, previous_total: u64, new_total: u64) -> Self {
        Self {
            vault,

            previous_total,

            new_total,
        }
    }
}

/// Custom struct: Withdraw
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct Withdraw {
    pub vault: Pubkey,

    pub caller: Pubkey,

    pub receiver: Pubkey,

    pub owner: Pubkey,

    pub assets: u64,

    pub shares: u64,
}

impl Withdraw {
    pub fn new(
        vault: Pubkey,

        caller: Pubkey,

        receiver: Pubkey,

        owner: Pubkey,

        assets: u64,

        shares: u64,
    ) -> Self {
        Self {
            vault,

            caller,

            receiver,

            owner,

            assets,

            shares,
        }
    }
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
